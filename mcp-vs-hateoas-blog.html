<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP and RESTful APIs: A resurfacing of HATEOAS in the AI era</title>
    <style>
        body {
            font-family: Georgia, serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #fafafa;
            color: #333;
        }
        
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        
        .code-block {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            margin: 20px 0;
            white-space: pre-wrap;
            font-size: 14px;
        }
        
        .highlight {
            background-color: #f39c12;
            padding: 2px 4px;
            border-radius: 3px;
            color: white;
        }
        
        .inline-code {
            background-color: #ecf0f1;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #e74c3c;
        }
    </style>
</head>
<body>
    <h1>MCP vs RESTful APIs: How HATEOAS Becomes Relevant Again in the AI Era</h1>
    
    <p>When Roy Fielding <a href="https://ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_blank" rel="noopener">introduced REST in his dissertation</a>, he outlined a clear architectural vision with three maturity levels that most developers recognize today:</p>
    
    <ul>
        <li><strong>Level 1:</strong> Resources - Everything has a URL</li>
        <li><strong>Level 2:</strong> HTTP Verbs - Use GET, POST, PUT, DELETE properly</li>
        <li><strong>Level 3:</strong> Hypermedia As the Engine of Application State , or <span class="highlight">HATEOAS</span></li>
    </ul>
    
    <p>While levels 1 and 2 have been adopted by industry, level 3 remains an academic ideal.

    <h2>What is HATEOAS?</h2>

    <p>Hypermedia as the Engine of Application State is the principle that APIs should tell clients what actions are available through embedded links</p>

    <div class="code-block">
// HATEOAS response example - positive balance
{
  "accountId": "acc-123",
  "accountHolder": "John Doe",
  "balance": 1250.75,
  "currency": "USD",
  "_links": {
    "self": {
      "href": "/accounts/acc-123"
    },
    "deposit": {
      "href": "/accounts/acc-123/deposit",
      "method": "POST"
    },
    "withdraw": {
      "href": "/accounts/acc-123/withdraw",
      "method": "POST"
    }
  }
}

// HATEOAS response example - overdraft
{
  "accountId": "acc-456",
  "accountHolder": "Jane Smith",
  "balance": -150.25,
  "currency": "USD",
  "_links": {
    "self": {
      "href": "/accounts/acc-456"
    },
    "deposit": {
      "href": "/accounts/acc-456/deposit",
      "method": "POST"
    }
  }
}
    </div>

    <p>This demonstrates HATEOAS in action: when the account has a positive balance, both deposit and withdraw operations are available. But when the account is in overdraft, only the deposit link appears - the server dynamically controls what actions are possible based on the current state.</p>

    <h2>Why didn't we adopt HATEOAS?</h2>

    <p>HATEOAS was challenging to implement because those theoretical advantages weren't meaningful in practice. Human developers prefer clear API documentation over parsing hypermedia, and despite the promise of decoupling, backend and frontend lifecycles tend to remain tightly coupled in real-world development.</p>
    
    <h2>What is MCP?</h2>

    <p>The Model Context Protocol (MCP) is a new approach to API discoverability designed specifically for machine clients, particularly AI agents. It allows these agents to dynamically discover available actions, data types, and workflows at runtime.</p>

    <div class="code-block">
// MCP list tools request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/list",
  "params": {}
}

// MCP server response
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "tools": [
      {
        "name": "read_file",
        "description": "Read contents of a file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "File path to read"
            }
          },
          "required": ["path"]
        }
      },
      {
        "name": "list_directory",
        "description": "List contents of a directory",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Directory path to list"
            }
          },
          "required": ["path"]
        }
      }
    ]
  }
}
    </div>

    <p>This demonstrates MCP's dynamic tool discovery - the AI agent queries available tools at runtime</p>

    <h2>MCP succeeds, not because it's better than HATEOAS, but because it's more timely</h2>

    <p>While HATEOAS failed because human developers don't need runtime discoverability- MCP succeeds because AI needs it</p>

    <p>HATEOAS was ahead of it's time. What was once an academic consideration is now a practical one. HATEOAS may find new life as a model that facilitates AI-driven interactions with APIs.</p>

    <h2>Dynamic Integration: MCP + HATEOAS in Practice</h2>
    
    <p>The real power emerges when we combine MCP's discovery capabilities with HATEOAS's state-driven navigation. My implementation demonstrates this by creating an MCP server that dynamically adapts its tool offerings based on the current state of a HATEOAS API.</p>
    
    <div class="code-block">
// MCP server discovers available actions from HATEOAS API
async discover_links() {
    const response = await this.client.get('/account');
    const data = response.json();
    
    // Update available tools based on current state
    this.cached_links = data._links;
    this.cached_tools = this._generate_tools_from_links();
    
    // Notify AI agent that tools have changed
    if (tools_changed) {
        await this._send_tool_refresh_notification();
    }
}

// Generate MCP tools from HATEOAS links
_generate_tools_from_links() {
    const tools = [];
    for (const [linkName, linkData] of Object.entries(this.cached_links)) {
        tools.push({
            name: linkName,
            description: `Execute ${linkData.rel} (${linkData.method})`,
            inputSchema: linkData.method === 'POST' ? {
                type: 'object',
                properties: { amount: { type: 'number' } },
                required: ['amount']
            } : {}
        });
    }
    return tools;
}
    </div>
    
    <p>This creates a feedback loop where:</p>
    <ul>
        <li>The HATEOAS API exposes different actions based on account state</li>
        <li>The MCP server dynamically updates its tool list</li>
        <li>The AI agent receives notifications about available actions</li>
        <li>Each action potentially changes the state, cycling back to step 1</li>
    </ul>
    
    <div class="code-block">
// Example: Account with positive balance
GET /account
{
  "balance": 1250.75,
  "_links": {
    "self": { "href": "/account" },
    "deposit": { "href": "/account/deposit", "method": "POST" },
    "withdraw": { "href": "/account/withdraw", "method": "POST" }
  }
}

// MCP tools available: ["self", "deposit", "withdraw"]

// After overdraft
POST /account/withdraw {"amount": 1300}
{
  "balance": -49.25,
  "_links": {
    "self": { "href": "/account" },
    "deposit": { "href": "/account/deposit", "method": "POST" }
  }
}

// MCP tools available: ["self", "deposit"]
// AI agent automatically loses withdraw capability
    </div>
    
    <p>This architecture enables AI agents to understand not just what actions exist, but <span class="highlight">when they're contextually appropriate</span>. The agent doesn't need to understand business rules - it simply adapts to what the API makes available.</p>
    
    <p>The implementation in <span class="inline-code">mcp-server.py</span> shows how this works in practice: the MCP server polls the HATEOAS API, regenerates its tool list based on available links, and notifies connected AI agents when capabilities change. This creates a truly dynamic, state-aware AI-API interaction model.</p>
    
    <p>You can find the complete implementation and examples at <a href="https://github.com/JonWoodlief/MCP-for-tier3-REST" target="_blank" rel="noopener">https://github.com/JonWoodlief/MCP-for-tier3-REST</a>.</p>
</body>
</html>