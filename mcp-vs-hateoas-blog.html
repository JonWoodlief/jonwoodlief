<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Missing Level in REST: API Discoverability from Academic Ideal to AI Necessity</title>
    <style>
        body {
            font-family: Georgia, serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #fafafa;
            color: #333;
        }
        
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        
        .code-block {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            margin: 20px 0;
            white-space: pre-wrap;
            font-size: 14px;
        }
        
        .highlight {
            background-color: #e8f4f8;
            padding: 2px 4px;
            border-radius: 3px;
            color: #2c5282;
            font-weight: 600;
        }
        
        .inline-code {
            background-color: #ecf0f1;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #e74c3c;
        }
        
        /* Syntax highlighting styles */
        .token.comment { color: #6a9955; }
        .token.string { color: #ce9178; }
        .token.number { color: #b5cea8; }
        .token.boolean { color: #569cd6; }
        .token.null { color: #569cd6; }
        .token.keyword { color: #c586c0; }
        .token.property { color: #9cdcfe; }
        .token.function { color: #dcdcaa; }
        .token.punctuation { color: #d4d4d4; }
        .token.operator { color: #d4d4d4; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-clike.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
</head>
<body>
    <h1>The Missing Level in REST: API Discoverability from Academic Ideal to AI Necessity</h1>
    
    <p>Most REST APIs today are incomplete. We build APIs that expose resources (Level 1) and use HTTP verbs correctly (Level 2), but we stop there. We skip Level 3 - the one that tells clients what they can actually do next.</p>
    
    <p>When Roy Fielding <a href="https://ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_blank" rel="noopener">introduced REST in his dissertation</a>, he outlined three maturity levels:</p>
    
    <ul>
        <li><strong>Level 1:</strong> Resources - Everything has a URL</li>
        <li><strong>Level 2:</strong> HTTP Verbs - Use GET, POST, PUT, DELETE properly</li>
        <li><strong>Level 3:</strong> Hypermedia As the Engine of Application State, or <span class="highlight">HATEOAS</span></li>
    </ul>
    
    <p>For decades, Level 3 remained an academic curiosity. Human developers didn't need it - they could parse extensive documentation and maintain context across complex workflows. But AI agents thrive on targeted, structured input delivered precisely when needed. They excel when APIs can provide exactly the right information at exactly the right moment.</p>

    <h2>What is HATEOAS?</h2>

    <p>Hypermedia as the Engine of Application State is the principle that APIs should tell clients what actions are available through embedded links. Instead of clients needing to know all possible endpoints upfront, the API response includes navigation instructions - like a GPS for your API interactions.</p>

    <div class="code-block">
<pre><code class="language-javascript">// HATEOAS response example - positive balance
{
  "accountId": "acc-123",
  "accountHolder": "John Doe",
  "balance": 1250.75,
  "currency": "USD",
  "_links": {
    "self": {
      "href": "/accounts/acc-123"
    },
    "deposit": {
      "href": "/accounts/acc-123/deposit",
      "method": "POST"
    },
    "withdraw": {
      "href": "/accounts/acc-123/withdraw",
      "method": "POST"
    }
  }
}

// HATEOAS response example - overdraft
{
  "accountId": "acc-456",
  "accountHolder": "Jane Smith",
  "balance": -150.25,
  "currency": "USD",
  "_links": {
    "self": {
      "href": "/accounts/acc-456"
    },
    "deposit": {
      "href": "/accounts/acc-456/deposit",
      "method": "POST"
    }
  }
}</code></pre>
    </div>

    <p>This demonstrates HATEOAS in action: when the account has a positive balance, both deposit and withdraw operations are available. But when the account is in overdraft, only the deposit link appears - the server dynamically controls what actions are possible based on the current state.</p>

    <h2>Why didn't we adopt HATEOAS?</h2>

    <p>HATEOAS was challenging to implement because those theoretical advantages weren't meaningful in practice. Human developers prefer clear API documentation over parsing hypermedia, and despite the promise of decoupling, backend and frontend lifecycles tend to remain tightly coupled in real-world development.</p>
    
    <h2>What is MCP?</h2>

    <p>The Model Context Protocol (MCP) is a new approach to API discoverability designed specifically for machine clients, particularly AI agents. Unlike traditional APIs that require upfront knowledge of available endpoints, MCP allows agents to ask "what can I do?" and receive structured, actionable responses at runtime.</p>

    <div class="code-block">
<pre><code class="language-json">// MCP list tools request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/list",
  "params": {}
}

// MCP server response
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "tools": [
      {
        "name": "read_file",
        "description": "Read contents of a file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "File path to read"
            }
          },
          "required": ["path"]
        }
      },
      {
        "name": "list_directory",
        "description": "List contents of a directory",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Directory path to list"
            }
          },
          "required": ["path"]
        }
      }
    ]
  }
}</code></pre>
    </div>

    <p>This demonstrates MCP's dynamic tool discovery - the AI agent queries available tools at runtime</p>

    <h2>HATEOAS Concepts Find Their Purpose with AI</h2>

    <p>While HATEOAS struggled to find adoption because human developers don't need runtime discoverability, MCP succeeds because AI agents thrive on it. The same principle that seemed unnecessary for humans becomes essential for machines.</p>

    <p>HATEOAS was ahead of its time. What was once an academic consideration is now a practical necessity. The structured, state-aware navigation that HATEOAS promised is exactly what AI agents need to operate effectively in complex systems.</p>

    <h2>Dynamic Integration: MCP + HATEOAS in Practice</h2>
    
    <p>The real power emerges when we combine MCP's discovery capabilities with HATEOAS's state-driven navigation. My implementation demonstrates this by creating an MCP server that dynamically adapts its tool offerings based on the current state of a HATEOAS API.</p>
    
    <div class="code-block">
<pre><code class="language-javascript">// MCP server discovers available actions from HATEOAS API
async discover_links() {
    const response = await this.client.get('/account');
    const data = response.json();
    
    // Update available tools based on current state
    this.cached_links = data._links;
    this.cached_tools = this._generate_tools_from_links();
    
    // Notify AI agent that tools have changed
    if (tools_changed) {
        await this._send_tool_refresh_notification();
    }
}

// Generate MCP tools from HATEOAS links
_generate_tools_from_links() {
    const tools = [];
    for (const [linkName, linkData] of Object.entries(this.cached_links)) {
        tools.push({
            name: linkName,
            description: `Execute ${linkData.rel} (${linkData.method})`,
            inputSchema: linkData.method === 'POST' ? {
                type: 'object',
                properties: { amount: { type: 'number' } },
                required: ['amount']
            } : {}
        });
    }
    return tools;
}</code></pre>
    </div>
    
    <p>This creates a feedback loop where:</p>
    <ul>
        <li>The HATEOAS API exposes different actions based on account state</li>
        <li>The MCP server dynamically updates its tool list</li>
        <li>The AI agent receives notifications about available actions</li>
        <li>Each action potentially changes the state, cycling back to step 1</li>
    </ul>
    
    <div class="code-block">
<pre><code class="language-javascript">// Example: Account with positive balance
GET /account
{
  "balance": 1250.75,
  "_links": {
    "self": { "href": "/account" },
    "deposit": { "href": "/account/deposit", "method": "POST" },
    "withdraw": { "href": "/account/withdraw", "method": "POST" }
  }
}

// MCP tools available: ["self", "deposit", "withdraw"]

// After overdraft
POST /account/withdraw {"amount": 1300}
{
  "balance": -49.25,
  "_links": {
    "self": { "href": "/account" },
    "deposit": { "href": "/account/deposit", "method": "POST" }
  }
}

// MCP tools available: ["self", "deposit"]
// AI agent automatically loses withdraw capability</code></pre>
    </div>
    
    <p>This architecture enables AI agents to understand not just what actions exist, but <span class="highlight">when they're contextually appropriate</span>. The agent doesn't need to understand business rules - it simply adapts to what the API makes available.</p>
    
    <p>The implementation in <span class="inline-code">mcp-server.py</span> shows how this works in practice: the MCP server polls the HATEOAS API, regenerates its tool list based on available links, and notifies connected AI agents when capabilities change. This creates a truly dynamic, state-aware AI-API interaction model.</p>
    
    <p>You can find the complete implementation and examples at <a href="https://github.com/JonWoodlief/MCP-for-tier3-REST" target="_blank" rel="noopener">https://github.com/JonWoodlief/MCP-for-tier3-REST</a>.</p>

<script>
    // Initialize Prism syntax highlighting
    if (typeof Prism !== 'undefined') {
        Prism.highlightAll();
    }
</script>
</body>
</html>